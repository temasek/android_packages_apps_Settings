From 7f5d85e44ca81f72d4e3dfb09e4f769143801df0 Mon Sep 17 00:00:00 2001
From: ValeraSh <9144287@gmail.com>
Date: Mon, 16 Dec 2013 19:50:49 +0400
Subject: [PATCH 34/56] Update V21

---
 Manifest.diff         |  18 +++
 boot.diff             |  20 ++++
 cm_arrays.diff        |  13 ++
 cm_plurals.diff       |  27 +++++
 cm_strings_GB.diff    |  28 +++++
 cm_strings_orig.diff  |  32 +++++
 cr_strings.diff       |  57 +++++++++
 cr_strings_v21.diff   |  13 ++
 development_java.diff |  28 +++++
 locanable.diff        |  87 ++++++++++++++
 location.diff         |  16 +++
 locbase.diff          |  53 +++++++++
 locset.diff           | 161 +++++++++++++++++++++++++
 lto.diff              | 320 ++++++++++++++++++++++++++++++++++++++++++++++++++
 settings_java.diff    |  64 ++++++++++
 wrapping.diff         |  51 ++++++++
 16 files changed, 988 insertions(+)
 create mode 100644 Manifest.diff
 create mode 100644 boot.diff
 create mode 100644 cm_arrays.diff
 create mode 100644 cm_plurals.diff
 create mode 100644 cm_strings_GB.diff
 create mode 100644 cm_strings_orig.diff
 create mode 100644 cr_strings.diff
 create mode 100644 cr_strings_v21.diff
 create mode 100644 development_java.diff
 create mode 100644 locanable.diff
 create mode 100644 location.diff
 create mode 100644 locbase.diff
 create mode 100644 locset.diff
 create mode 100644 lto.diff
 create mode 100644 settings_java.diff
 create mode 100644 wrapping.diff

diff --git a/Manifest.diff b/Manifest.diff
new file mode 100644
index 0000000..9a338a0
--- /dev/null
+++ b/Manifest.diff
@@ -0,0 +1,18 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\And6E9C.tmp\\AndroidManifest-a306630-left.xml" "b/D:\\Temp\\TortoiseGit\\And6E9B.tmp\\AndroidManifest-4528e68-right.xml"
+index 7f47c81..f01c3f6 100644
+--- "a/D:\\Temp\\TortoiseGit\\And6E9C.tmp\\AndroidManifest-a306630-left.xml"
++++ "b/D:\\Temp\\TortoiseGit\\And6E9B.tmp\\AndroidManifest-4528e68-right.xml"
+@@ -1997,5 +1997,13 @@
+                 android:name="android.support.FILE_PROVIDER_PATHS"
+                 android:resource="@xml/file_paths" />
+         </provider>
++
++        <!-- Lto Service -->
++        <service android:label="LtoService"
++            android:enabled="true"
++            android:exported="false"
++            android:name=".cyanogenmod.LtoService">
++        </service>
++
+     </application>
+ </manifest>
diff --git a/boot.diff b/boot.diff
new file mode 100644
index 0000000..bd78910
--- /dev/null
+++ b/boot.diff
@@ -0,0 +1,20 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\Boo19A2.tmp\\BootReceiver-a306630-left.java" "b/D:\\Temp\\TortoiseGit\\Boo19A1.tmp\\BootReceiver-4528e68-right.java"
+index 3ff8a4f..a7392c2 100644
+--- "a/D:\\Temp\\TortoiseGit\\Boo19A2.tmp\\BootReceiver-a306630-left.java"
++++ "b/D:\\Temp\\TortoiseGit\\Boo19A1.tmp\\BootReceiver-4528e68-right.java"
+@@ -30,6 +30,7 @@ import com.android.settings.Utils;
+ import com.android.settings.hardware.DisplayColor;
+ import com.android.settings.hardware.DisplayGamma;
+ import com.android.settings.hardware.VibratorIntensity;
++import com.android.settings.location.LocationSettings;
+ 
+ import java.util.Arrays;
+ import java.util.List;
+@@ -75,6 +76,7 @@ public class BootReceiver extends BroadcastReceiver {
+         DisplayGamma.restore(ctx);
+         VibratorIntensity.restore(ctx);
+         DisplaySettings.restore(ctx);
++        LocationSettings.restore(ctx);
+     }
+ 
+     private void initFreqCapFiles(Context ctx)
diff --git a/cm_arrays.diff b/cm_arrays.diff
new file mode 100644
index 0000000..ffc8c99
--- /dev/null
+++ b/cm_arrays.diff
@@ -0,0 +1,13 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\cm_E2F1.tmp\\cm_arrays-a306630-left.xml" "b/D:\\Temp\\TortoiseGit\\cm_E2F0.tmp\\cm_arrays-4528e68-right.xml"
+index 0945060..cdad143 100644
+--- "a/D:\\Temp\\TortoiseGit\\cm_E2F1.tmp\\cm_arrays-a306630-left.xml"
++++ "b/D:\\Temp\\TortoiseGit\\cm_E2F0.tmp\\cm_arrays-4528e68-right.xml"
+@@ -14,7 +14,7 @@
+      See the License for the specific language governing permissions and
+      limitations under the License.
+ -->
+-<resources>
++<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+     <!-- Wi-Fi settings. Presented as a list dialog to the user to choose the Wi-Fi region code. -->
+     <string-array name="wifi_countrycode_entries">
+         <item>United States</item>
diff --git a/cm_plurals.diff b/cm_plurals.diff
new file mode 100644
index 0000000..92bc8fd
--- /dev/null
+++ b/cm_plurals.diff
@@ -0,0 +1,27 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\Pat543D.tmp.xml" "b/D:\\Temp\\TortoiseGit\\cm_543C.tmp\\cm_plurals-4528e68.xml"
+index e69de29..c6943e3 100644
+--- "a/D:\\Temp\\TortoiseGit\\Pat543D.tmp.xml"
++++ "b/D:\\Temp\\TortoiseGit\\cm_543C.tmp\\cm_plurals-4528e68.xml"
+@@ -0,0 +1,22 @@
++<?xml version="1.0" encoding="utf-8"?>
++<!--
++     Copyright (C) 2013 The CyanogenMod Project
++
++     Licensed under the Apache License, Version 2.0 (the "License");
++     you may not use this file except in compliance with the License.
++     You may obtain a copy of the License at
++
++          http://www.apache.org/licenses/LICENSE-2.0
++
++     Unless required by applicable law or agreed to in writing, software
++     distributed under the License is distributed on an "AS IS" BASIS,
++     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++     See the License for the specific language governing permissions and
++     limitations under the License.
++-->
++<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
++    <plurals name="backlight_timeout_time">
++        <item quantity="one"><xliff:g id="seconds">%d</xliff:g> second</item>
++        <item quantity="other"><xliff:g id="seconds">%d</xliff:g> seconds</item>
++    </plurals>
++</resources>
diff --git a/cm_strings_GB.diff b/cm_strings_GB.diff
new file mode 100644
index 0000000..5a675a2
--- /dev/null
+++ b/cm_strings_GB.diff
@@ -0,0 +1,28 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\Pat616C.tmp.xml" "b/D:\\Temp\\TortoiseGit\\cm_616B.tmp\\cm_strings-4528e68.xml"
+index e69de29..eb2e15e 100644
+--- "a/D:\\Temp\\TortoiseGit\\Pat616C.tmp.xml"
++++ "b/D:\\Temp\\TortoiseGit\\cm_616B.tmp\\cm_strings-4528e68.xml"
+@@ -0,0 +1,23 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<resources xmlns:android="http://schemas.android.com/apk/res/android"
++    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
++     <string name="dialog_test_message">Turn the screen off to see the selected notification in action or dismiss this dialogue box to stop the test</string>
++     <string name="battery_light_list_title">Colours</string>
++     <string name="lockscreen_maximize_widgets_title">Maximise widgets</string>
++     <string name="lockscreen_maximize_widgets_summary">Show widgets maximised and the unlock minimised when the screen is turned on</string>
++     <string name="cyanogenmod_waiver_body">Changing this setting may be against your state or government laws.\n\nBy selecting \'OK\' below, you acknowledge this warning and waive, indemnify and hold harmless CyanogenMod and its contributors from all legal liabilities.</string>
++     <string name="title_tile_airplane">Aeroplane mode</string>
++     <string name="title_collapse_panel">Auto-close panel</string>
++     <string name="header_category_interface">Personalisation</string>
++     <string name="processor_summary">Change CPU governor and clock speed</string>
++     <string name="cpu_set_on_boot">Set on boot</string>
++     <string name="cpu_set_on_boot_summary">Restore the processor settings on boot</string>
++     <string name="io_scheds_summary">Change I/O scheduler</string>
++     <string name="io_sched_set_on_boot">Set on boot</string>
++     <string name="io_sched_set_on_boot_summary">Restore the I/O scheduler settings on boot</string>
++     <string name="color_calibration_title">Colour calibration</string>
++     <string name="color_calibration_summary">Calibrate on-screen colours</string>
++     <string name="notification_drawer_collapse_on_dismiss_title">Auto-close behaviour</string>
++     <string name="sms_security_check_limit_summary">Apps can send %d messages in 30 minutes before requiring confirmation</string>
++    <string name="adaptive_backlight_summary">Intelligently vary the backlight brightness of the display and help maximise battery life</string>
++</resources>
diff --git a/cm_strings_orig.diff b/cm_strings_orig.diff
new file mode 100644
index 0000000..8f34a7d
--- /dev/null
+++ b/cm_strings_orig.diff
@@ -0,0 +1,32 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\cm_DB90.tmp\\cm_strings-a306630-left.xml" "b/D:\\Temp\\TortoiseGit\\cm_DB8F.tmp\\cm_strings-4528e68-right.xml"
+index 9ee8130..a431329 100644
+--- "a/D:\\Temp\\TortoiseGit\\cm_DB90.tmp\\cm_strings-a306630-left.xml"
++++ "b/D:\\Temp\\TortoiseGit\\cm_DB8F.tmp\\cm_strings-4528e68-right.xml"
+@@ -1,5 +1,6 @@
+ <?xml version="1.0" encoding="utf-8"?>
+-<!-- Copyright (C) 2012-2013 The CyanogenMod Project
++<!--
++     Copyright (C) 2012-2013 The CyanogenMod Project
+ 
+      Licensed under the Apache License, Version 2.0 (the "License");
+      you may not use this file except in compliance with the License.
+@@ -628,10 +629,6 @@ two in order to insert additional control points. \'Remove\' deletes the selecte
+     <string name="keyboard_backlight_seekbar_title">Keyboard brightness</string>
+     <string name="backlight_timeout_title">Illumination timeout</string>
+     <string name="backlight_timeout_unlimited">Don\'t turn off</string>
+-    <plurals name="backlight_timeout_time">
+-        <item quantity="one"><xliff:g id="seconds">%d</xliff:g> second</item>
+-        <item quantity="other"><xliff:g id="seconds">%d</xliff:g> seconds</item>
+-    </plurals>
+     <string name="backlight_summary_disabled">Disabled</string>
+     <string name="backlight_summary_enabled_with_timeout">Enabled for <xliff:g id="timeout">%s</xliff:g></string>
+     <string name="backlight_summary_enabled">Enabled</string>
+@@ -652,4 +649,8 @@ two in order to insert additional control points. \'Remove\' deletes the selecte
+     <!-- Message of dialog confirming that user wants to restart their device with a new runtime -->
+     <string name="custom_runtime_warning_title">Warning</string>
+     <string name="custom_runtime_warning_message">ART is not supported by CyanogenMod. This setting is included for experimentation only and has the potential to cause instability, crashes, data loss or prevent the proper boot of your device. Visit &lt;a href=\"http://source.android.com/devices/tech/dalvik/art.html\"&gt;Introducing ART&lt;/a&gt; for more information.&lt;br/&gt;&lt;br/&gt;We request you do not file bug reports if you have enabled ART as your runtime.&lt;br/&gt;&lt;br/&gt;Are you sure you want to reboot to change runtime from <xliff:g id="old" example="libdvm.so">%1$s</xliff:g> to <xliff:g id="new" example="libart.so">%2$s</xliff:g>?</string>
++
++    <!-- GPS download data over wi-fi only -->
++    <string name="gps_download_data_wifi_only">Download GPS assisted data only over Wi-Fi networks</string>
++
+ </resources>
diff --git a/cr_strings.diff b/cr_strings.diff
new file mode 100644
index 0000000..eacd012
--- /dev/null
+++ b/cr_strings.diff
@@ -0,0 +1,57 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\cr_F90.tmp\\cr_strings-a306630-left.xml" "b/D:\\Temp\\TortoiseGit\\cr_F80.tmp\\cr_strings-4528e68-right.xml"
+index 0e16305..84eb671 100644
+--- "a/D:\\Temp\\TortoiseGit\\cr_F90.tmp\\cr_strings-a306630-left.xml"
++++ "b/D:\\Temp\\TortoiseGit\\cr_F80.tmp\\cr_strings-4528e68-right.xml"
+@@ -557,8 +557,12 @@
+     <string name="ad_pocket_mode_title">Džepni način</string>
+     <string name="ad_pocket_mode_summary">Prikaži obavijesti u aktivnom prikazu kad izvadite uređaj iz džepa.</string>
+     <string name="ad_redisplay_title">Ponovni prikaz obavijesti</string>
++    <string name="ad_timeout_title">Istek prikaza</string>
++    <string name="ad_threshold_title">Prag blizine</string>
+     <string name="ad_sunlight_mode_title">Način jake svjetlosti</string>
+     <string name="ad_sunlight_mode_summary">Obrni boje u područjima jake svjetlosti, poput direktne sunčeve svjetlosti.</string>
++    <string name="ad_turnoff_mode_title">Isključi prikaz</string>
++    <string name="ad_turnoff_mode_summary">Isključi prikaz ako je uređaj vraćen u džep, a bio je upaljen kroz aktivni prikaz.</string>
+     <string name="ad_customizations_title">Prilagodbe</string>
+     <string name="ad_excluded_apps_title">Isključene aplikacije</string>
+     <string name="ad_excluded_apps_summary">Isključene aplikacije neće biti prikazane u aktivnom prikazu.</string>
+@@ -576,6 +580,18 @@
+     <string name="ad_redisplay_1h">1 sat</string>
+     <string name="ad_redisplay_2h">2 sata</string>
+     <string name="ad_redisplay_5h">5 sati</string>
++    <string name="ad_timeout_3s">3 sekunde</string>
++    <string name="ad_timeout_5s">5 sekundi</string>
++    <string name="ad_timeout_8s">8 sekundi</string>
++    <string name="ad_timeout_10s">10 sekundi</string>
++    <string name="ad_timeout_15s">15 sekundi</string>
++    <string name="ad_timeout_25s">25 sekundi</string>
++    <string name="ad_threshold_0s">Odmah</string>
++    <string name="ad_threshold_1s">1 sekunda</string>
++    <string name="ad_threshold_2s">2 sekunde</string>
++    <string name="ad_threshold_3s">3 sekunde</string>
++    <string name="ad_threshold_4s">4 sekunde</string>
++    <string name="ad_threshold_5s">5 sekundi</string>
+     <string name="ad_pocket_mode_off">Isključeno</string>
+     <string name="ad_pocket_mode_notifications">Samo obavijesti</string>
+     <string name="ad_pocket_mode_always">Uvijek</string>
+@@ -662,6 +678,11 @@
+     <string name="title_tile_expanded_desktop">Prošireni prikaz</string>
+     <string name="title_tile_music">Glazba</string>
+     <string name="title_tile_reboot">Ponovno pokretanje</string>
++    <string name="dynamic_tile_ime_switcher">IME promjena</string>
++    <string name="dynamic_tile_usb_tether">USB povezivanje</string>
++    <string name="dynamic_tile_alarm">Alarm</string>
++    <string name="dynamic_tile_bugreport">Prijava kvara</string>
++    <string name="dynamic_tiles_title">Dinamične pločice</string>
+     <string name="tiles_reset_message">Vrati početne postavke?</string>
+     <string name="disable_qs">Brze postavke su onemogućene</string>
+     <string name="disable_qs_message">Sve pločice su izbrisane. Brze postavke su onemogućene.\n\nDa bi omogućili brze postavke dodajte pločicu.</string>
+@@ -672,7 +693,7 @@
+     <string name="summary_quicksettings_tiles_style">Pregledajte ili promjenite izgled brzih postavki</string>
+     <string name="quicksettings_tiles_style_additional_options">Dodatne mogućnosti</string>
+     <string name="tiles_per_row_title">Pločica u redu</string>
+-    <string name="tiles_per_row_duplicate_landscape_title">Scale landscape quantity</string>
++    <string name="tiles_per_row_duplicate_landscape_title">Rastegni brojnost u pejsažnom načinu</string>
+     <string name="tiles_per_row_duplicate_landscape_summary">Pejsažni prikaz prikazuje dvostruki broj pločica u redu</string>
+     <string name="quick_tiles_bg_color_title">Boja pozadine pločica</string>
+     <string name="quick_tiles_bg_pressed_color_title">Boja pozadine pritisnute pločice</string>
diff --git a/cr_strings_v21.diff b/cr_strings_v21.diff
new file mode 100644
index 0000000..bb74f8d
--- /dev/null
+++ b/cr_strings_v21.diff
@@ -0,0 +1,13 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\cr_96A4.tmp\\cr_strings-a306630-left.xml" "b/D:\\Temp\\TortoiseGit\\cr_9694.tmp\\cr_strings-4528e68-right.xml"
+index 4434dc0..c9df56b 100644
+--- "a/D:\\Temp\\TortoiseGit\\cr_96A4.tmp\\cr_strings-a306630-left.xml"
++++ "b/D:\\Temp\\TortoiseGit\\cr_9694.tmp\\cr_strings-4528e68-right.xml"
+@@ -5,7 +5,7 @@
+     <!-- About phone screen, temasek version -->
+     <string name="temasek_version_title">Temasek unofficial version</string>
+     <!-- Do NOT Translate this -->
+-    <string name="temasek_version_default">V20.2-private</string>
++    <string name="temasek_version_default">V21</string>
+ 
+     <!-- General strings -->
+     <string name="reset">Reset</string>
diff --git a/development_java.diff b/development_java.diff
new file mode 100644
index 0000000..730b285
--- /dev/null
+++ b/development_java.diff
@@ -0,0 +1,28 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\Dev618A.tmp\\DevelopmentSettings-a306630-left.java" "b/D:\\Temp\\TortoiseGit\\Dev6189.tmp\\DevelopmentSettings-4528e68-right.java"
+index f6c663d..baf059e 100644
+--- "a/D:\\Temp\\TortoiseGit\\Dev618A.tmp\\DevelopmentSettings-a306630-left.java"
++++ "b/D:\\Temp\\TortoiseGit\\Dev6189.tmp\\DevelopmentSettings-4528e68-right.java"
+@@ -1487,11 +1487,18 @@ public class DevelopmentSettings extends RestrictedSettingsFragment
+             if (!newRuntimeValue.equals(oldRuntimeValue)) {
+                 final Context context = getActivity();
+                 final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+-                //builder.setMessage(context.getResources().getString(R.string.select_runtime_warning_message,
+-                //                                                    oldRuntimeValue, newRuntimeValue));
+-                builder.setMessage(Html.fromHtml(context.getResources().getString(R.string.custom_runtime_warning_message,
+-                        oldRuntimeValue, newRuntimeValue)));
+-                builder.setTitle(context.getResources().getString(R.string.custom_runtime_warning_title));
++                if (oldRuntimeValue.equals("libart.so")) {
++                    builder.setMessage(context.getResources().getString(
++                            R.string.select_runtime_warning_message,
++                            oldRuntimeValue, newRuntimeValue));
++                } else {
++                    builder.setMessage(Html.fromHtml(
++                            context.getResources().getString(
++                                    R.string.custom_runtime_warning_message,
++                                    oldRuntimeValue, newRuntimeValue)));
++                    builder.setTitle(context.getResources().getString(
++                            R.string.custom_runtime_warning_title));
++                }
+                 builder.setPositiveButton(android.R.string.ok, new OnClickListener() {
+                     @Override
+                     public void onClick(DialogInterface dialog, int which) {
diff --git a/locanable.diff b/locanable.diff
new file mode 100644
index 0000000..60b2345
--- /dev/null
+++ b/locanable.diff
@@ -0,0 +1,87 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\PatA3C9.tmp.java" "b/D:\\Temp\\TortoiseGit\\LocA3C8.tmp\\LocationEnabler-4528e68.java"
+index e69de29..e2972b6 100644
+--- "a/D:\\Temp\\TortoiseGit\\PatA3C9.tmp.java"
++++ "b/D:\\Temp\\TortoiseGit\\LocA3C8.tmp\\LocationEnabler-4528e68.java"
+@@ -0,0 +1,82 @@
++/*
++ * Copyright (C) 2013 The CyanogenMod Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.location;
++
++import android.content.Context;
++import android.provider.Settings;
++import android.util.Log;
++import android.widget.CompoundButton;
++import android.widget.Switch;
++
++public class LocationEnabler implements CompoundButton.OnCheckedChangeListener  {
++    private static final String TAG = "LocationEnabler";
++    private final Context mContext;
++    private Switch mSwitch;
++    private boolean mStateMachineEvent;
++
++    public LocationEnabler(Context context, Switch switch_) {
++        mContext = context;
++        mSwitch = switch_;
++    }
++
++    public void resume() {
++        mSwitch.setOnCheckedChangeListener(this);
++        setSwitchState();
++    }
++
++    public void pause() {
++        mSwitch.setOnCheckedChangeListener(null);
++    }
++
++    public void setSwitch(Switch switch_) {
++        if (mSwitch == switch_) return;
++        mSwitch.setOnCheckedChangeListener(null);
++        mSwitch = switch_;
++        mSwitch.setOnCheckedChangeListener(this);
++        setSwitchState();
++    }
++
++    private void setSwitchState() {
++        int mode = Settings.Secure.getInt(mContext.getContentResolver(),
++                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);
++        mStateMachineEvent = true;
++        mSwitch.setChecked(mode != Settings.Secure.LOCATION_MODE_OFF);
++        mStateMachineEvent = false;
++    }
++
++    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
++        if (mStateMachineEvent) {
++            return;
++        }
++        // Handle a switch change
++        if (LocationSettingsBase.isRestricted(mContext)) {
++            // Location toggling disabled by user restriction. Read the current location mode to
++            // update the location master switch.
++            if (Log.isLoggable(TAG, Log.INFO)) {
++                Log.i(TAG, "Restricted user, not setting location mode");
++            }
++            return;
++        }
++
++        int currentMode = Settings.Secure.getInt(mContext.getContentResolver(),
++                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);
++        int newMode = isChecked ? Settings.Secure.LOCATION_MODE_HIGH_ACCURACY
++                : Settings.Secure.LOCATION_MODE_OFF;
++        LocationSettingsBase.sendModeChangingIntent(mContext, currentMode, newMode);
++    }
++
++}
diff --git a/location.diff b/location.diff
new file mode 100644
index 0000000..4d040b9
--- /dev/null
+++ b/location.diff
@@ -0,0 +1,16 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\locF531.tmp\\location_settings-a306630-left.xml" "b/D:\\Temp\\TortoiseGit\\locF530.tmp\\location_settings-4528e68-right.xml"
+index 83b80b1..7189ef2 100644
+--- "a/D:\\Temp\\TortoiseGit\\locF531.tmp\\location_settings-a306630-left.xml"
++++ "b/D:\\Temp\\TortoiseGit\\locF530.tmp\\location_settings-4528e68-right.xml"
+@@ -21,6 +21,11 @@
+             android:title="@string/location_mode_title"
+             android:summary="@string/location_mode_location_off_title" />
+ 
++        <com.android.settings.WrappingCheckBoxPreference
++            android:key="gps_download_data_wifi_only"
++            android:title="@string/gps_download_data_wifi_only"
++            android:defaultValue="true" />
++
+         <PreferenceCategory
+             android:key="recent_location_requests"
+             android:title="@string/location_category_recent_location_requests" />
diff --git a/locbase.diff b/locbase.diff
new file mode 100644
index 0000000..302385a
--- /dev/null
+++ b/locbase.diff
@@ -0,0 +1,53 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\Loc40E8.tmp\\LocationSettingsBase-a306630-left.java" "b/D:\\Temp\\TortoiseGit\\Loc40E7.tmp\\LocationSettingsBase-4528e68-right.java"
+index 86c2ee5..c160833 100644
+--- "a/D:\\Temp\\TortoiseGit\\Loc40E8.tmp\\LocationSettingsBase-a306630-left.java"
++++ "b/D:\\Temp\\TortoiseGit\\Loc40E7.tmp\\LocationSettingsBase-4528e68-right.java"
+@@ -71,13 +71,13 @@ public abstract class LocationSettingsBase extends SettingsPreferenceFragment
+     /** Called when location mode has changed. */
+     public abstract void onModeChanged(int mode, boolean restricted);
+ 
+-    private boolean isRestricted() {
+-        final UserManager um = (UserManager) getActivity().getSystemService(Context.USER_SERVICE);
++    protected static boolean isRestricted(Context context) {
++        final UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);
+         return um.hasUserRestriction(UserManager.DISALLOW_SHARE_LOCATION);
+     }
+ 
+     public void setLocationMode(int mode) {
+-        if (isRestricted()) {
++        if (isRestricted(getActivity())) {
+             // Location toggling disabled by user restriction. Read the current location mode to
+             // update the location master switch.
+             if (Log.isLoggable(TAG, Log.INFO)) {
+@@ -90,20 +90,25 @@ public abstract class LocationSettingsBase extends SettingsPreferenceFragment
+             }
+             return;
+         }
+-        Intent intent = new Intent(MODE_CHANGING_ACTION);
+-        intent.putExtra(CURRENT_MODE_KEY, mCurrentMode);
+-        intent.putExtra(NEW_MODE_KEY, mode);
+-        getActivity().sendBroadcast(intent, android.Manifest.permission.WRITE_SECURE_SETTINGS);
+-        Settings.Secure.putInt(getContentResolver(), Settings.Secure.LOCATION_MODE, mode);
++        sendModeChangingIntent(getActivity(), mCurrentMode, mode);
+         refreshLocationMode();
+     }
+ 
++    protected static void sendModeChangingIntent(Context context, int oldState, int newState) {
++        Intent intent = new Intent(MODE_CHANGING_ACTION);
++        intent.putExtra(CURRENT_MODE_KEY, oldState);
++        intent.putExtra(NEW_MODE_KEY, newState);
++        context.sendBroadcast(intent, android.Manifest.permission.WRITE_SECURE_SETTINGS);
++        Settings.Secure.putInt(context.getContentResolver(),
++                Settings.Secure.LOCATION_MODE, newState);
++    }
++
+     public void refreshLocationMode() {
+         if (mActive) {
+             int mode = Settings.Secure.getInt(getContentResolver(), Settings.Secure.LOCATION_MODE,
+                     Settings.Secure.LOCATION_MODE_OFF);
+             mCurrentMode = mode;
+-            onModeChanged(mode, isRestricted());
++            onModeChanged(mode, isRestricted(getActivity()));
+         }
+     }
+ 
diff --git a/locset.diff b/locset.diff
new file mode 100644
index 0000000..23d2cfb
--- /dev/null
+++ b/locset.diff
@@ -0,0 +1,161 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\LocFFA7.tmp\\LocationSettings-a306630-left.java" "b/D:\\Temp\\TortoiseGit\\LocFFA6.tmp\\LocationSettings-4528e68-right.java"
+index 06a6650..c3a2495 100644
+--- "a/D:\\Temp\\TortoiseGit\\LocFFA7.tmp\\LocationSettings-a306630-left.java"
++++ "b/D:\\Temp\\TortoiseGit\\LocFFA6.tmp\\LocationSettings-4528e68-right.java"
+@@ -18,17 +18,24 @@ package com.android.settings.location;
+ 
+ import android.app.ActionBar;
+ import android.app.Activity;
++import android.app.AlarmManager;
++import android.app.PendingIntent;
+ import android.content.BroadcastReceiver;
+ import android.content.Context;
+ import android.content.Intent;
+ import android.content.IntentFilter;
++import android.content.SharedPreferences;
++import android.content.pm.PackageManager;
+ import android.location.LocationManager;
+ import android.location.SettingInjectorService;
+ import android.os.Bundle;
++import android.preference.CheckBoxPreference;
+ import android.preference.Preference;
++import android.preference.Preference.OnPreferenceChangeListener;
+ import android.preference.PreferenceActivity;
+ import android.preference.PreferenceCategory;
+ import android.preference.PreferenceGroup;
++import android.preference.PreferenceManager;
+ import android.preference.PreferenceScreen;
+ import android.provider.Settings;
+ import android.util.Log;
+@@ -37,6 +44,9 @@ import android.widget.CompoundButton;
+ import android.widget.Switch;
+ 
+ import com.android.settings.R;
++import com.android.settings.cyanogenmod.LtoService;
++
++import org.cyanogenmod.hardware.LongTermOrbits;
+ 
+ import java.util.Collections;
+ import java.util.Comparator;
+@@ -46,12 +56,14 @@ import java.util.List;
+  * Location access settings.
+  */
+ public class LocationSettings extends LocationSettingsBase
+-        implements CompoundButton.OnCheckedChangeListener {
++        implements CompoundButton.OnCheckedChangeListener, OnPreferenceChangeListener {
+ 
+     private static final String TAG = "LocationSettings";
+ 
+     /** Key for preference screen "Mode" */
+     private static final String KEY_LOCATION_MODE = "location_mode";
++    /** Key for preference screen "LTO - WiFi Only" */
++    public static final String KEY_GPS_DOWNLOAD_DATA_WIFI_ONLY = "gps_download_data_wifi_only";
+     /** Key for preference category "Recent location requests" */
+     private static final String KEY_RECENT_LOCATION_REQUESTS = "recent_location_requests";
+     /** Key for preference category "Location services" */
+@@ -60,6 +72,7 @@ public class LocationSettings extends LocationSettingsBase
+     private Switch mSwitch;
+     private boolean mValidListener;
+     private Preference mLocationMode;
++    private CheckBoxPreference mGpsDownloadDataWifiOnly;
+     private PreferenceCategory mCategoryRecentLocationRequests;
+     /** Receives UPDATE_INTENT  */
+     private BroadcastReceiver mReceiver;
+@@ -124,6 +137,17 @@ public class LocationSettings extends LocationSettingsBase
+                     }
+                 });
+ 
++        mGpsDownloadDataWifiOnly =
++                (CheckBoxPreference) root.findPreference(KEY_GPS_DOWNLOAD_DATA_WIFI_ONLY);
++        if (mGpsDownloadDataWifiOnly != null) {
++            if (!LongTermOrbits.isSupported() || !checkGpsDownloadWiFiOnly(getActivity())) {
++                root.removePreference(mGpsDownloadDataWifiOnly);
++                mGpsDownloadDataWifiOnly = null;
++            } else {
++                mGpsDownloadDataWifiOnly.setOnPreferenceChangeListener(this);
++            }
++        }
++
+         mCategoryRecentLocationRequests =
+                 (PreferenceCategory) root.findPreference(KEY_RECENT_LOCATION_REQUESTS);
+         RecentLocationApps recentApps = new RecentLocationApps(activity);
+@@ -184,6 +208,7 @@ public class LocationSettings extends LocationSettingsBase
+                     Log.d(TAG, "Received settings change intent: " + intent);
+                 }
+                 injector.reloadStatusMessages();
++                refreshLocationMode();
+             }
+         };
+ 
+@@ -229,6 +254,9 @@ public class LocationSettings extends LocationSettingsBase
+         // be disabled but checked.
+         boolean enabled = (mode != Settings.Secure.LOCATION_MODE_OFF);
+         mSwitch.setEnabled(!restricted);
++        if (mGpsDownloadDataWifiOnly != null) {
++            mGpsDownloadDataWifiOnly.setEnabled(enabled && !restricted);
++        }
+         mLocationMode.setEnabled(enabled && !restricted);
+         mCategoryRecentLocationRequests.setEnabled(enabled);
+ 
+@@ -255,4 +283,61 @@ public class LocationSettings extends LocationSettingsBase
+             setLocationMode(Settings.Secure.LOCATION_MODE_OFF);
+         }
+     }
++
++    @Override
++    public boolean onPreferenceChange(Preference preference, Object newValue) {
++        if (mGpsDownloadDataWifiOnly != null && preference.equals(mGpsDownloadDataWifiOnly)) {
++            updateLtoServiceStatus(getActivity(), isLocationModeEnabled(getActivity()));
++        }
++        return true;
++    }
++
++    private static void updateLtoServiceStatus(Context context, boolean start) {
++        Intent intent = new Intent(context, LtoService.class);
++        if (start) {
++            context.startService(intent);
++        } else {
++            context.stopService(intent);
++        }
++    }
++
++    private static boolean checkGpsDownloadWiFiOnly(Context context) {
++        PackageManager pm = context.getPackageManager();
++        boolean supportsTelephony = pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
++        boolean supportsWifi = pm.hasSystemFeature(PackageManager.FEATURE_WIFI);
++        if (!supportsWifi || !supportsTelephony) {
++            SharedPreferences.Editor editor =
++                    PreferenceManager.getDefaultSharedPreferences(context).edit();
++            editor.putBoolean(KEY_GPS_DOWNLOAD_DATA_WIFI_ONLY, supportsWifi);
++            editor.apply();
++            return false;
++        }
++        return true;
++    }
++
++    public static boolean isLocationModeEnabled(Context context) {
++        int mode = Settings.Secure.getInt(context.getContentResolver(),
++                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);
++        return (mode != Settings.Secure.LOCATION_MODE_OFF);
++    }
++
++    /**
++     * Restore the properties associated with this preference on boot
++     * @param ctx A valid context
++     */
++    public static void restore(final Context context) {
++        if (LongTermOrbits.isSupported() && isLocationModeEnabled(context)) {
++            // Check and adjust the value for Gps download data on wifi only
++            checkGpsDownloadWiFiOnly(context);
++
++            // Starts the LtoService, but delayed 2 minutes after boot (this should give a
++            // proper time to start all device services)
++            AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
++            Intent intent = new Intent(context, LtoService.class);
++            PendingIntent pi = PendingIntent.getService(context, 0, intent,
++                    PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_ONE_SHOT);
++            long nextLtoDownload = System.currentTimeMillis() + (1000 * 60 * 2L);
++            am.set(AlarmManager.RTC, nextLtoDownload, pi);
++        }
++    }
+ }
diff --git a/lto.diff b/lto.diff
new file mode 100644
index 0000000..943a877
--- /dev/null
+++ b/lto.diff
@@ -0,0 +1,320 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\Pat5B04.tmp.java" "b/D:\\Temp\\TortoiseGit\\Lto5B03.tmp\\LtoService-4528e68.java"
+index e69de29..86909b9 100644
+--- "a/D:\\Temp\\TortoiseGit\\Pat5B04.tmp.java"
++++ "b/D:\\Temp\\TortoiseGit\\Lto5B03.tmp\\LtoService-4528e68.java"
+@@ -0,0 +1,315 @@
++/*
++ * Copyright (C) 2013 The CyanogenMod Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.cyanogenmod;
++
++import android.app.AlarmManager;
++import android.app.PendingIntent;
++import android.app.Service;
++import android.content.Context;
++import android.content.Intent;
++import android.content.SharedPreferences;
++import android.net.ConnectivityManager;
++import android.net.NetworkInfo;
++import android.os.AsyncTask;
++import android.os.IBinder;
++import android.os.PowerManager;
++import android.os.PowerManager.WakeLock;
++import android.preference.PreferenceManager;
++import android.util.Log;
++
++import com.android.settings.location.LocationSettings;
++
++import org.apache.http.HttpEntity;
++import org.apache.http.HttpResponse;
++import org.apache.http.client.HttpClient;
++import org.apache.http.client.methods.HttpGet;
++import org.apache.http.impl.client.DefaultHttpClient;
++import org.apache.http.params.BasicHttpParams;
++import org.apache.http.params.HttpConnectionParams;
++import org.apache.http.params.HttpParams;
++import org.cyanogenmod.hardware.LongTermOrbits;
++
++import java.io.BufferedInputStream;
++import java.io.BufferedOutputStream;
++import java.io.File;
++import java.io.FileOutputStream;
++import java.io.IOException;
++import java.net.URI;
++import java.net.URISyntaxException;
++import java.util.Date;
++
++public class LtoService extends Service {
++    private static final String TAG = "LtoService";
++    private static final boolean ALOGV = true;
++
++    private static final String KEY_LAST_DOWNLOAD = "lto_last_download";
++
++    public static final String ACTION_NEW_GPS_DATA = "com.cyanogenmod.actions.NEW_GPS_DATA";
++
++    private static final int DOWNLOAD_TIMEOUT = 20000; /* 20 seconds */
++
++    private LtoDownloadTask mTask;
++
++    @Override
++    public int onStartCommand(Intent intent, int flags, int startId) {
++        if (!LongTermOrbits.isSupported()) {
++            if (ALOGV) Log.v(TAG, "LTO is not supported by this device");
++            return START_NOT_STICKY;
++        }
++        if (!LocationSettings.isLocationModeEnabled(this)) {
++            if (ALOGV) Log.v(TAG, "Location mode not enabled in this device");
++            return START_NOT_STICKY;
++        }
++
++        if (mTask != null && mTask.getStatus() != AsyncTask.Status.FINISHED) {
++            if (ALOGV) Log.v(TAG, "LTO download is still active, not starting new download");
++            return START_REDELIVER_INTENT;
++        }
++
++        if (!shouldDownload()) {
++            Log.d(TAG, "Service started, but shouldn't download ... stopping");
++            stopSelf();
++            return START_NOT_STICKY;
++        }
++
++        mTask = new LtoDownloadTask(
++                LongTermOrbits.getSourceLocation(), LongTermOrbits.getDestinationLocation());
++        mTask.execute();
++
++        return START_REDELIVER_INTENT;
++    }
++
++    @Override
++    public IBinder onBind(Intent intent) {
++        return null;
++    }
++
++    @Override
++    public void onDestroy() {
++        if (mTask != null && mTask.getStatus() != AsyncTask.Status.FINISHED) {
++            mTask.cancel(true);
++            mTask = null;
++        }
++    }
++
++    private boolean shouldDownload() {
++        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
++        ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
++        NetworkInfo info = cm.getActiveNetworkInfo();
++
++        if (info == null || !info.isConnected()) {
++            if (ALOGV) Log.v(TAG, "No network connection is available for LTO download");
++        } else {
++            boolean wifiOnly = prefs.getBoolean(
++                    LocationSettings.KEY_GPS_DOWNLOAD_DATA_WIFI_ONLY, true);
++            if (wifiOnly && info.getType() != ConnectivityManager.TYPE_WIFI) {
++                if (ALOGV) {
++                    Log.v(TAG, "Active network is of type " +
++                            info.getTypeName() + ", but Wifi only was selected");
++                }
++                return false;
++            }
++        }
++
++        long now = System.currentTimeMillis();
++        long lastDownload = getLastDownload();
++        long due = lastDownload + LongTermOrbits.getDownloadInterval();
++
++        if (ALOGV) {
++            Log.v(TAG, "Now " + now + " due " + due + "(" + new Date(due) + ")");
++        }
++
++        if (lastDownload != 0 && now < due) {
++            if (ALOGV) Log.v(TAG, "LTO download is not due yet");
++            return false;
++        }
++
++        return true;
++    }
++
++    private class LtoDownloadTask extends AsyncTask<Void, Integer, Integer> {
++        private String mSource;
++        private File mDestination;
++        private File mTempFile;
++        private WakeLock mWakeLock;
++
++        private static final int RESULT_SUCCESS = 0;
++        private static final int RESULT_FAILURE = 1;
++        private static final int RESULT_CANCELLED = 2;
++
++        public LtoDownloadTask(String source, File destination) {
++            mSource = source;
++            mDestination = destination;
++            try {
++                mTempFile = File.createTempFile("lto-download", null, getCacheDir());
++            } catch (IOException e) {
++                Log.w(TAG, "Could not create temporary file", e);
++            }
++
++            PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);
++            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
++        }
++
++        @Override
++        protected void onPreExecute() {
++            mWakeLock.acquire();
++        }
++
++        @Override
++        protected Integer doInBackground(Void... params) {
++            BufferedInputStream in = null;
++            BufferedOutputStream out = null;
++            int result = RESULT_SUCCESS;
++
++            try {
++                HttpParams httpParams = new BasicHttpParams();
++                HttpConnectionParams.setConnectionTimeout(httpParams, DOWNLOAD_TIMEOUT);
++                HttpConnectionParams.setSoTimeout(httpParams, DOWNLOAD_TIMEOUT);
++
++                HttpClient client = new DefaultHttpClient(httpParams);
++                HttpGet request = new HttpGet();
++                request.setURI(new URI(mSource));
++
++                HttpResponse response = client.execute(request);
++                HttpEntity entity = response.getEntity();
++                File outputFile = mTempFile != null ? mTempFile : mDestination;
++
++                in = new BufferedInputStream(entity.getContent());
++                out = new BufferedOutputStream(new FileOutputStream(outputFile));
++
++                byte[] buffer = new byte[2048];
++                int count, total = 0;
++                long length = entity.getContentLength();
++
++                while ((count = in.read(buffer, 0, buffer.length)) != -1) {
++                    if (isCancelled()) {
++                        result = RESULT_CANCELLED;
++                        break;
++                    }
++                    out.write(buffer, 0, count);
++                    total += count;
++
++                    if (length > 0) {
++                        float progress = (float) total * 100 / length;
++                        publishProgress((int) progress);
++                    }
++                }
++
++                Log.d(TAG, "Downloaded " + total + "/" + length + " bytes of LTO data");
++                if (total == 0 || (length > 0 && total != length)) {
++                    result = RESULT_FAILURE;
++                }
++                in.close();
++                out.close();
++            } catch (IOException e) {
++                Log.e(TAG, "Failed downloading LTO data", e);
++                result = RESULT_FAILURE;
++            } catch (URISyntaxException e) {
++                Log.e(TAG, "URI syntax wrong", e);
++                result = RESULT_FAILURE;
++            } finally {
++                try {
++                    if (in != null) {
++                        in.close();
++                    }
++                    if (out != null) {
++                        out.close();
++                    }
++                } catch (IOException e) {
++                    e.printStackTrace();
++                }
++            }
++
++            Log.d(TAG, "return " + result);
++            return result;
++        }
++
++        @Override
++        protected void onPostExecute(Integer result) {
++            if (result != null) {
++                finish(result);
++            }
++        }
++
++        @Override
++        protected void onCancelled() {
++            finish(RESULT_CANCELLED);
++        }
++
++        private void finish(int result) {
++            final Context context = LtoService.this;
++
++            if (mTempFile != null) {
++                if (result == RESULT_SUCCESS) {
++                    mDestination.delete();
++                    if (!mTempFile.renameTo(mDestination)) {
++                        Log.w(TAG, "Could not move temporary file to destination");
++                    } else {
++                        mDestination.setReadable(true, false);
++                    }
++                }
++                mTempFile.delete();
++            } else if (result != RESULT_SUCCESS) {
++                mDestination.delete();
++            } else {
++                mDestination.setReadable(true, false);
++            }
++
++            if (result == RESULT_SUCCESS) {
++                long now = System.currentTimeMillis();
++                SharedPreferences.Editor editor =
++                        PreferenceManager.getDefaultSharedPreferences(context).edit();
++                editor.putLong(KEY_LAST_DOWNLOAD, now);
++                editor.apply();
++                scheduleNextDownload(now);
++                notifyNewGpsData();
++
++            } else if (result == RESULT_FAILURE) {
++                /* failure, schedule next download in 1 hour */
++                long lastDownload = getLastDownload() + (60 * 60 * 1000);
++                scheduleNextDownload(lastDownload);
++            } else {
++                /* cancelled, likely due to lost network - we'll get restarted
++                 * when network comes back */
++            }
++
++            mWakeLock.release();
++            stopSelf();
++        }
++    }
++
++    private void notifyNewGpsData() {
++        Intent intent = new Intent(ACTION_NEW_GPS_DATA);
++        sendStickyBroadcast(intent);
++    }
++
++    private PendingIntent scheduleNextDownload(long lastDownload) {
++        AlarmManager am = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
++        Intent intent = new Intent(this, LtoService.class);
++        PendingIntent pi = PendingIntent.getService(this, 0, intent,
++                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_ONE_SHOT);
++
++        long nextLtoDownload = lastDownload + LongTermOrbits.getDownloadInterval();
++        am.set(AlarmManager.RTC, nextLtoDownload, pi);
++        return pi;
++    }
++
++    private long getLastDownload() {
++        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
++        return prefs.getLong(LtoService.KEY_LAST_DOWNLOAD, 0);
++    }
++}
diff --git a/settings_java.diff b/settings_java.diff
new file mode 100644
index 0000000..e0bd86b
--- /dev/null
+++ b/settings_java.diff
@@ -0,0 +1,64 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\SetF688.tmp\\Settings-a306630-left.java" "b/D:\\Temp\\TortoiseGit\\SetF678.tmp\\Settings-4528e68-right.java"
+index 1f5b6b7..934d452 100644
+--- "a/D:\\Temp\\TortoiseGit\\SetF688.tmp\\Settings-a306630-left.java"
++++ "b/D:\\Temp\\TortoiseGit\\SetF678.tmp\\Settings-4528e68-right.java"
+@@ -88,6 +88,7 @@ import com.android.settings.inputmethod.InputMethodAndLanguageSettings;
+ import com.android.settings.inputmethod.KeyboardLayoutPickerFragment;
+ import com.android.settings.inputmethod.SpellCheckersSettings;
+ import com.android.settings.inputmethod.UserDictionaryList;
++import com.android.settings.location.LocationEnabler;
+ import com.android.settings.location.LocationSettings;
+ import com.android.settings.nfc.AndroidBeam;
+ import com.android.settings.nfc.PaymentSettings;
+@@ -833,7 +834,7 @@ public class Settings extends PreferenceActivity
+         private final BluetoothEnabler mBluetoothEnabler;
+         private final ProfileEnabler mProfileEnabler;
+         private final TRDSEnabler mTRDSEnabler;
+-
++        private final LocationEnabler mLocationEnabler;
+         private AuthenticatorHelper mAuthHelper;
+         private DevicePolicyManager mDevicePolicyManager;
+ 
+@@ -854,7 +855,8 @@ public class Settings extends PreferenceActivity
+             } else if (header.id == R.id.wifi_settings
+                     || header.id == R.id.bluetooth_settings
+                     || header.id == R.id.profiles_settings
+-                    || header.id == R.id.trds_settings) {
++                    || header.id == R.id.trds_settings
++                    || header.id == R.id.location_settings) {
+                 return HEADER_TYPE_SWITCH;
+             } else if (header.id == R.id.security_settings) {
+                 return HEADER_TYPE_BUTTON;
+@@ -901,6 +903,7 @@ public class Settings extends PreferenceActivity
+             mWifiEnabler = new WifiEnabler(context, new Switch(context));
+             mBluetoothEnabler = new BluetoothEnabler(context, new Switch(context));
+             mProfileEnabler = new ProfileEnabler(context, new Switch(context));
++            mLocationEnabler = new LocationEnabler(context, new Switch(context));
+             mDevicePolicyManager = dpm;
+             mTRDSEnabler = new TRDSEnabler(context, new Switch(context));
+         }
+@@ -978,6 +981,8 @@ public class Settings extends PreferenceActivity
+                     } else if (header.id == R.id.trds_settings) {
+                         mTRDSSwitch = (Switch) view.findViewById(R.id.switchWidget);
+                         mTRDSEnabler.setSwitch(holder.switch_);
++                    } else if (header.id == R.id.location_settings) {
++                        mLocationEnabler.setSwitch(holder.switch_);
+                     }
+                     updateCommonHeaderView(header, holder);
+                     break;
+@@ -1053,6 +1058,7 @@ public class Settings extends PreferenceActivity
+             mBluetoothEnabler.resume();
+             mProfileEnabler.resume();
+             mTRDSEnabler.resume();
++            mLocationEnabler.resume();
+         }
+ 
+         public void pause() {
+@@ -1060,6 +1066,7 @@ public class Settings extends PreferenceActivity
+             mBluetoothEnabler.pause();
+             mProfileEnabler.pause();
+             mTRDSEnabler.pause();
++            mLocationEnabler.pause();
+         }
+     }
+ 
diff --git a/wrapping.diff b/wrapping.diff
new file mode 100644
index 0000000..94d819f
--- /dev/null
+++ b/wrapping.diff
@@ -0,0 +1,51 @@
+diff --git "a/D:\\Temp\\TortoiseGit\\PatD12D.tmp.java" "b/D:\\Temp\\TortoiseGit\\WraD12C.tmp\\WrappingCheckBoxPreference-4528e68.java"
+index e69de29..6c3b2e0 100644
+--- "a/D:\\Temp\\TortoiseGit\\PatD12D.tmp.java"
++++ "b/D:\\Temp\\TortoiseGit\\WraD12C.tmp\\WrappingCheckBoxPreference-4528e68.java"
+@@ -0,0 +1,45 @@
++/*
++ * Copyright (C) 2011 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings;
++
++import android.content.Context;
++import android.preference.CheckBoxPreference;
++import android.util.AttributeSet;
++import android.view.View;
++import android.widget.TextView;
++
++public class WrappingCheckBoxPreference extends CheckBoxPreference {
++
++    public WrappingCheckBoxPreference(Context context, AttributeSet attrs, int defStyle) {
++        super(context, attrs, defStyle);
++    }
++
++    public WrappingCheckBoxPreference(Context context, AttributeSet attrs) {
++        super(context, attrs);
++    }
++
++    @Override
++    protected void onBindView(View view) {
++        super.onBindView(view);
++
++        TextView title = (TextView) view.findViewById(android.R.id.title);
++        if (title != null) {
++            title.setSingleLine(false);
++            title.setMaxLines(3);
++        }
++    }
++}
+\ No newline at end of file
-- 
1.8.4.msysgit.0

